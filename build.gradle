import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar

plugins {
    id 'java'
    id 'application'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
}

group = 'org.f14a.fatin2'
// Versions are defined in gradle.properties:
// - version (host app)
// - version_demoplugin, version_tachibana (internal plugins)

// Java version
java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

repositories {
    mavenCentral()
}

dependencies {
    // Annotations
    implementation 'org.jetbrains:annotations:24.0.0'

    // WebSocket client library
    implementation 'org.java-websocket:Java-WebSocket:1.6.0'

    // Json processing library
    implementation 'com.google.code.gson:gson:2.13.2'

    // YAML processing library
    implementation 'org.yaml:snakeyaml:2.5'

    // Logging library
    implementation 'org.slf4j:slf4j-api:2.0.9'
    implementation 'ch.qos.logback:logback-classic:1.5.21'

    // Tools
    implementation 'org.apache.commons:commons-lang3:3.18.0'

    // Tests
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.3'
}

application {
    mainClass = 'org.f14a.fatin2.Main'
}

// --- Custom source sets for internal plugins (built as separate jars) ---
sourceSets {
    demoplugin {
        java {
            srcDir 'src/main/java'
            include 'org/f14a/demoplugin/**'
        }
        // Allow plugin sources to reference the host API + host dependencies at compile time.
        // NOTE: This does *not* mean they will be packaged into the plugin JAR.
        // IMPORTANT for IDEs: use the source set's own configurations (demopluginCompileClasspath, etc.)
        // so IntelliJ can model dependencies correctly.
        compileClasspath += sourceSets.main.output + configurations.demopluginCompileClasspath
        runtimeClasspath += output + compileClasspath + configurations.demopluginRuntimeClasspath
    }
    tachibana {
        java {
            srcDir 'src/main/java'
            include 'org/f14a/tachibana/**'
        }
        compileClasspath += sourceSets.main.output + configurations.tachibanaCompileClasspath
        runtimeClasspath += output + compileClasspath + configurations.tachibanaRuntimeClasspath
    }
}

// --- Plugin dependency model ---
// Each plugin gets its own dependency bucket.
// - *CompileOnly* is for the host API (classes from main source set)
// - *Implementation/RuntimeOnly* are plugin-specific deps that should be bundled into the plugin JAR
//
// Why this matters:
// - Using a plain `Jar` task only packages *your classes*.
// - If you want a plugin to carry dependencies the host doesn't ship, you must build a shaded jar.
configurations {
    // Make pluginImplementation participate in plugin runtime resolution.
    // This improves IDE import resolution and ensures plugin shadow tasks can resolve deps.
    demopluginRuntimeClasspath.extendsFrom(demopluginImplementation)
    tachibanaRuntimeClasspath.extendsFrom(tachibanaImplementation)
}

// Compile-only dependency on the host app APIs
// (plugins can call host code, but the host classes must NOT be duplicated into plugin jars)
dependencies {
    demopluginCompileOnly sourceSets.main.output
    tachibanaCompileOnly sourceSets.main.output

    // Plugin-only deps (bundled into the plugin shaded jar)
    tachibanaImplementation 'com.github.oshi:oshi-core:6.9.2'
}

// --- Main application artifacts ---
// Adding new plugin source sets won’t require manually excluding packages.
jar {
    archiveBaseName.set('fatin2')
    archiveVersion.set(project.version.toString())
    // Standard Jar output named as: fatin2-{version}-standard.jar
    archiveClassifier.set('standard')

    // Only package the main application code
    include 'org/f14a/fatin2/**'

    manifest {
        attributes(
            'Main-Class': application.mainClass.get(),
            'Implementation-Title': project.name,
            'Implementation-Version': project.version
        )
    }
}

// Shadow jar should be the primary runnable distribution.
shadowJar {
    archiveBaseName.set('fatin2')
    archiveVersion.set(project.version.toString())
    // Requirement: shadowJar output named as: fatin2-{version}.jar
    archiveClassifier.set('')

    exclude('org/f14a/demoplugin/**')
    exclude('org/f14a/tachibana/**')

    manifest {
        attributes(
            'Main-Class': application.mainClass.get(),
            'Implementation-Title': project.name,
            'Implementation-Version': project.version
        )
    }
}

// Ensure normal build produces both host artifacts.
// Internal plugin jars are intentionally NOT part of the default build lifecycle.
// (This allows you to iterate on plugins independently; a plugin compile error won’t break the host release build.)
build.dependsOn jar, shadowJar

// --- Plugin jars ---
// These tasks are opt-in. Run them explicitly when you want to build internal plugins.
//
// IMPORTANT:
// Use ShadowJar (fat jar) for plugins that need their own dependencies.
// A plain Jar task won't include external libraries.

// Demo plugin shaded jar (copied into run/plugins for local dev)
tasks.register('buildDemoplugin', ShadowJar) {
    group = 'demoplugin'
    description = 'Build the demo plugin shaded JAR (includes plugin dependencies)'

    archiveBaseName.set('demoplugin')
    archiveVersion.set(version_demoplugin)
    archiveClassifier.set('')

    from(sourceSets.demoplugin.output)
    configurations = [project.configurations.demopluginRuntimeClasspath]

    destinationDirectory.set(file("$projectDir/run/plugins"))

    manifest {
        attributes(
            'Name': 'DemoPlugin',
            'Version': version_demoplugin,
            'Plugin-Main-Class': 'org.f14a.demoplugin.Main'
        )
    }

    doFirst {
        file("$projectDir/run/plugins").mkdirs()
    }
}

// Tachibana plugin shaded jar (bundles OSHI + transitive deps)
tasks.register('buildTachibana', ShadowJar) {
    group = 'tachibana'
    description = 'Build the Tachibana plugin shaded JAR (includes plugin dependencies)'

    archiveBaseName.set('tachibana')
    archiveVersion.set(version_tachibana)
    archiveClassifier.set('')

    from(sourceSets.tachibana.output)
    configurations = [project.configurations.tachibanaRuntimeClasspath]

    destinationDirectory.set(file("$projectDir/run/plugins"))

    manifest {
        attributes(
            'Name': 'Tachibana',
            'Version': version_tachibana,
            'Plugin-Main-Class': 'org.f14a.tachibana.Main'
        )
    }

    // Avoid shading host-provided dependencies if you want (optional).
    // For example, if the host already provides SLF4J/Logback, shading a second copy can cause conflicts.
    // exclude(dependency('org.slf4j:slf4j-api:.*'))

    doFirst {
        file("$projectDir/run/plugins").mkdirs()
    }
}

// Utility task to run the bot (without automatically building plugins)
tasks.register('runBot', JavaExec) {
    group = 'application'
    description = 'Run the Fatin2 bot'

    classpath = sourceSets.main.runtimeClasspath
    mainClass = application.mainClass.get()
    workingDir = file("$projectDir/run")

    doFirst {
        file("$projectDir/run").mkdirs()
    }

    if (project.hasProperty('args')) {
        args project.property('args').toString().split('\\s+')
    }
}

// Clean up generated plugin jars on clean
clean {
    delete "$projectDir/run/plugins/demoplugin-${version_demoplugin}.jar"
    delete "$projectDir/run/plugins/tachibana-${version_tachibana}.jar"
}

// Test configuration
test {
    workingDir = file("$projectDir/test")
    useJUnitPlatform()
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
    options.compilerArgs << '-Xlint:unchecked' << '-Xlint:deprecation'
}
