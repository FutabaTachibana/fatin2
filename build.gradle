plugins {
    id 'java'
    id 'application'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
}

group = 'org.f14a.fatin2'
// Versions are defined in gradle.properties:
// - version (host app)
// - version_demoplugin, version_tachibana (internal plugins)

// Java version
java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

repositories {
    mavenCentral()
}

dependencies {
    // Annotations
    implementation 'org.jetbrains:annotations:24.0.0'

    // WebSocket client library
    implementation 'org.java-websocket:Java-WebSocket:1.6.0'

    // Json processing library
    implementation 'com.google.code.gson:gson:2.13.2'

    // YAML processing library
    implementation 'org.yaml:snakeyaml:2.5'

    // Logging library
    implementation 'org.slf4j:slf4j-api:2.0.9'
    implementation 'ch.qos.logback:logback-classic:1.5.21'

    // Tools
    implementation 'org.apache.commons:commons-lang3:3.18.0'

    // Tests
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.3'
}

application {
    mainClass = 'org.f14a.fatin2.Main'
}

// --- Custom source sets for internal plugins (built as separate jars) ---
sourceSets {
    demoplugin {
        java {
            srcDir 'src/main/java'
            include 'org/f14a/demoplugin/**'
        }
        // Inherit host dependencies so plugins can compile against shared libs (e.g., Gson)
        compileClasspath += sourceSets.main.output + configurations.compileClasspath
    }
    tachibana {
        java {
            srcDir 'src/main/java'
            include 'org/f14a/tachibana/**'
        }
        compileClasspath += sourceSets.main.output + configurations.compileClasspath
    }
}

// Compile-only dependency on the host app APIs
dependencies {
    demopluginCompileOnly sourceSets.main.output
    tachibanaCompileOnly sourceSets.main.output
}

// --- Main application artifacts ---
// Adding new plugin source sets won’t require manually excluding packages.
jar {
    archiveBaseName.set('fatin2')
    archiveVersion.set(project.version.toString())
    // Standard Jar output named as: fatin2-{version}-standard.jar
    archiveClassifier.set('standard')

    // Only package the main application code
    include 'org/f14a/fatin2/**'

    manifest {
        attributes(
            'Main-Class': application.mainClass.get(),
            'Implementation-Title': project.name,
            'Implementation-Version': project.version
        )
    }
}

// Shadow jar should be the primary runnable distribution.
shadowJar {
    archiveBaseName.set('fatin2')
    archiveVersion.set(project.version.toString())
    // Requirement: shadowJar output named as: fatin2-{version}.jar
    archiveClassifier.set('')

    exclude('org/f14a/demoplugin/**')
    exclude('org/f14a/tachibana/**')

    manifest {
        attributes(
            'Main-Class': application.mainClass.get(),
            'Implementation-Title': project.name,
            'Implementation-Version': project.version
        )
    }
}

// Ensure normal build produces both host artifacts.
// Internal plugin jars are intentionally NOT part of the default build lifecycle.
// (This allows you to iterate on plugins independently; a plugin compile error won’t break the host release build.)
build.dependsOn jar, shadowJar

// --- Plugin jars ---
// These tasks are opt-in. Run them explicitly when you want to build internal plugins.
// Example:
//   ./gradlew buildDemoplugin
//   ./gradlew buildTachibana
// Demo plugin jar (copied into run/plugins for local dev)
tasks.register('buildDemoplugin', Jar) {
    group = 'demoplugin'
    description = 'Build the demo plugin JAR'

    archiveBaseName.set('demoplugin')
    archiveVersion.set(version_demoplugin)
    archiveClassifier.set('')

    from(sourceSets.demoplugin.output)

    destinationDirectory.set(file("$projectDir/run/plugins"))

    manifest {
        attributes(
            'Name': 'DemoPlugin',
            'Version': version_demoplugin,
            'Plugin-Main-Class': 'org.f14a.demoplugin.Main'
        )
    }

    doFirst {
        file("$projectDir/run/plugins").mkdirs()
    }
}

// Tachibana plugin jar
tasks.register('buildTachibana', Jar) {
    group = 'tachibana'
    description = 'Build the tachibana plugin JAR'

    archiveBaseName.set('tachibana')
    archiveVersion.set(version_tachibana)
    archiveClassifier.set('')

    from(sourceSets.tachibana.output)

    destinationDirectory.set(file("$projectDir/run/plugins"))

    manifest {
        attributes(
            'Name': 'Tachibana',
            'Version': version_tachibana,
            'Plugin-Main-Class': 'org.f14a.tachibana.Main'
        )
    }

    doFirst {
        file("$projectDir/run/plugins").mkdirs()
    }
}

// Utility task to run the bot (without automatically building plugins)
tasks.register('runBot', JavaExec) {
    group = 'application'
    description = 'Run the Fatin2 bot'

    classpath = sourceSets.main.runtimeClasspath
    mainClass = application.mainClass.get()
    workingDir = file("$projectDir/run")

    doFirst {
        file("$projectDir/run").mkdirs()
    }

    if (project.hasProperty('args')) {
        args project.property('args').toString().split('\\s+')
    }
}

// Clean up generated plugin jars on clean
clean {
    delete "$projectDir/run/plugins/demoplugin-${version_demoplugin}.jar"
    delete "$projectDir/run/plugins/tachibana-${version_tachibana}.jar"
}

// Test configuration
test {
    workingDir = file("$projectDir/test")
    useJUnitPlatform()
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
    options.compilerArgs << '-Xlint:unchecked' << '-Xlint:deprecation'
}
